{
  "test1": {
    "rma": "reduce the level of abstraction in your package. This could mean that you need to break down complex classes into simpler, more concrete components or use more primitive types instead of abstract ones. /n/nYou may also want to consider moving certain methods or pieces of functionality out of abstract classes and into a concrete class, if that functionality is specific and doesn't need to be reused elsewhere. /n/nIt's always a good idea to keep your code as simple and straightforward as possible, while still maintaining the necessary level of functionality",
    "avgNMO": "1. Follow Interfaces: Interfaces define the contract for classes and contain methods that classes need to implement. Using interfaces allows you to use method overriding appropriately./n/n2. Principle of Least Knowledge: This principle, also known as Law of Demeter, suggests a class shouldnâ€™t know about the inner details of other classes. This can prevent unnecessary method overriding./n/n3. Use Composition over Inheritance: Although inheritance allows for method overriding, it's often more beneficial to use composition. It enables you to reuse code across",
    "dn": "implement better object-oriented programming principles. A high DN value represents a high discrepancy between your current code and a proper Object-Oriented Design. Some principles to remember include inheritance, encapsulation, abstraction, and polymorphism./n/nInheritance involves creating new classes using classes that have already been defined./nEncapsulation involves hiding the details of the implementation and exposing only the methods./nAbstraction involves simplifying complex systems by breaking them down into smaller, more manageable parts./nPolymorphism allows one interface to be used",
    "avgWMC": "1. Refactor your code: Break down complex methods into simpler ones. Each method should have a single responsibility, to do one thing and do it well./n/n2. Limit the responsibilities of each class: Class should only have methods that pertain to their specific functionality. Avoid having classes that do many different tasks./n/n3. Encapsulate behaviors: Group related methods together in their respective classes. Ensure they openly expose select behaviors necessary for other classes./n/n4. Use inheritance and polymorphism: Instead of",
    "rmi": "1. Minimize the dependencies between the classes within your package. /n/n2. Follow the Principle of High Cohesion and Low Coupling. This means that classes within the same package should be closely related to each other and should not depend too much on classes from other packages./n/n3. Break down large classes or methods into smaller ones and distribute them into different packages if necessary. /n/n4. Regularly refactor your codes to make the classes in your package more maintainable./n\\n5. Create clear interfaces and"
  }
}